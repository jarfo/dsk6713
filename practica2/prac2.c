//************************************************************************
//								 PRAC2.C
//
//						  Modulaciones banda base
//========================================================================
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "C6713dskinit.h"
#include "codec.h"

#define SIMB_BUFF	100       // Number of symbols in each block
#define AMPLITUD	16384
#define MUESTRAS_SIMBOLO 8
#define LBUFF		SIMB_BUFF*MUESTRAS_SIMBOLO
typedef struct {
	int *bits, nbits, index;
} SEQUENCE;

// The input sequence is generated by the periodic concatenation of the first ninput_bits bits of input_bits
#define ninput_bits 4
int input_bits[] = {1,1,0,0};
int buffer1[LBUFF], buffer2[LBUFF];
int BITS[SIMB_BUFF + 3]; // +3 since the hdb3 algorithm need previous 3 bits
int *iobuffer = buffer1;
int *oblock = buffer2;
int sample=0;

void init_arrays() 
{
	int i;
	for (i=0;i<LBUFF;i++)
		buffer1[i] = buffer2[i] = 0;
	sample=0;
}
void init_user(USER *pUsr) 
{
	pUsr->lSymb = MUESTRAS_SIMBOLO;
	pUsr->V = AMPLITUD;
	pUsr->state.lastBit = 0;
	pUsr->state.sgnOne  = 1;
	pUsr->state.dc = 0;
	pUsr->state.zeroes  = 3;
	pUsr->nbits = SIMB_BUFF;
	pUsr->bits = &BITS[3];
	pUsr->bits[-3] = pUsr->bits[-2] = pUsr->bits[-1] = 0;
}

void wait_buffer (void) 
{
	int *pt;
	while (sample < LBUFF);

	pt = oblock;
	oblock = iobuffer;
	iobuffer = pt;

	sample = 0;
}

void read_bits(SEQUENCE *pSeq, int nbits, int *bits) {
	int i;
	for (i=0; i<nbits; i++) {
		bits[i] = pSeq->bits[pSeq->index++];
		if (pSeq->index == pSeq->nbits)
			pSeq->index = 0;
	}
}

interrupt void c_int11() {
	if (sample<LBUFF)
		output_sample(iobuffer[sample++]);
}

void main (void) {
	Uint32 fs=DSK6713_AIC23_FREQ_16KHZ;  // Sampling frequency
	SEQUENCE seq = {input_bits, ninput_bits, 0};
	USER usr;
	init_arrays();
	init_user(&usr);                     // Init state variables
	comm_intr(fs);                       // DSK Init
	while(1) {
		wait_buffer();
		read_bits(&seq, usr.nbits, usr.bits);
		cod_rz(&usr, oblock, (usr.lSymb)/2);
		//cod_polar (&usr, oblock);
		//cod_bipolar (&usr, oblock);
	}
}
